ë°”ë‚˜ë‚˜ ì½”ë¦¬ì•ˆ - ìµœì¢… ì™„ì„± ê³„íšì„œ
ğŸŒ í”„ë¡œì íŠ¸ ê°œìš”
íƒ€ê²Ÿ
ì§€ì—­: ì „ ì„¸ê³„
ì£¼ìš” ì‚¬ìš©ì: ì™¸êµ­ì¸ì„ ê°€ë¥´ì¹˜ëŠ” í•œêµ­ì¸ í•œêµ­ì–´ ì„ ìƒë‹˜
ë¶€ì°¨ ì‚¬ìš©ì: ì™¸êµ­ì¸ ì„ ìƒë‹˜, ê°œì¸ í•™ìŠµì
í•™ìŠµì: ì „ ì„¸ê³„ í•œêµ­ì–´ í•™ìŠµì
í•µì‹¬ ì°¨ë³„ì 
ëŒ€í™” ê¸°ë°˜ ë§¥ë½ í•™ìŠµ: ëª¨ë“  ë¬¸ì œê°€ ëŒ€í™” í˜•ì‹
AI ë§ì¶¤ ë¬¸ì œ ìƒì„±: ì„ ìƒë‹˜ì´ ë‹¨ì–´/ë¬¸ë²• ì„ íƒ â†’ AIê°€ ì¦‰ì‹œ ìƒì„±
ì„ ìƒë‹˜-í•™ìƒ í”Œë«í¼: ìˆ™ì œ ë¶€ì—¬, ì§„ë„ ê´€ë¦¬, ìë™ ì±„ì 
ğŸ’³ êµ¬ë… í”Œëœ (ìµœì¢… í™•ì •)
ë¬´ë£Œ (Free) - $0
âœ… ê¸°ì¡´ ë¬¸ì œ ë¬´ì œí•œ í’€ê¸°
âœ… Matching í€´ì¦ˆ (ê¸°ì¡´ ë‹¨ì–´ë§Œ)
âœ… ì§„ë„ ì¶”ì , ì•½ì  ë¶„ì„, ì„±ì·¨ ë°°ì§€
âœ… AI ìƒì„± (ì£¼ 1íšŒ)
   - ê°„ë‹¨/ì»¤ìŠ¤í…€ ëª¨ë“œ í•©ì³ì„œ ì£¼ 1íšŒ
   - 1íšŒë‹¹ ìµœëŒ€ 100ê°œ ë¬¸ì œ (Speaking ì œì™¸)
âŒ Speaking í€´ì¦ˆ
âŒ ìˆ™ì œ ë¶€ì—¬ ê¸°ëŠ¥ (ì„ ìƒë‹˜)
âŒ í•™ìƒ ê´€ë¦¬

ì—­í• : ì„ ìƒë‹˜/í•™ìƒ ë™ì¼
í•™ìƒ í”„ë¡œ (Student Pro) - $9.99/ì›”
âœ… ë¬´ë£Œ ëª¨ë“  ê¸°ëŠ¥
âœ… AI ìƒì„± (ì›” 20íšŒ)
   - ê°„ë‹¨ + ì»¤ìŠ¤í…€ í•©ì³ì„œ 20íšŒ
   - 1íšŒë‹¹ ìµœëŒ€ 100ê°œ ë¬¸ì œ
âœ… Speaking í€´ì¦ˆ
   - ê°„ë‹¨ ëª¨ë“œ: ë¬´ì œí•œ (ì‚¬ì „ ìƒì„± ë¬¸ì œ)
   - ì»¤ìŠ¤í…€ ëª¨ë“œ: ìµœëŒ€ 400ê°œ/ì›” (20íšŒÃ—20ê°œ)
   - AI: GPT-4o mini
âœ… 7ì¼ ë¬´ë£Œ ì²´í—˜ (ì¹´ë“œ ë“±ë¡ ë¶ˆí•„ìš”)
âŒ ìˆ™ì œ ë¶€ì—¬ ë¶ˆê°€
âŒ í•™ìƒ ê´€ë¦¬ ë¶ˆê°€

ëŒ€ìƒ: ê°œì¸ í•™ìŠµì
ì„ ìƒë‹˜ í”„ë¡œ (Teacher Pro) - $14.99/ì›”
âœ… í•™ìƒ í”„ë¡œ ëª¨ë“  ê¸°ëŠ¥
âœ… AI ìƒì„± (ì›” 20íšŒ)
âœ… Speaking í€´ì¦ˆ (ì›” 400ê°œ)
âœ… í•™ìƒ ê´€ë¦¬ (ìµœëŒ€ 30ëª…)
âœ… ìˆ™ì œ ë§Œë“¤ê¸° & ë¶€ì—¬
   - ê°„ë‹¨ ëª¨ë“œ
   - ì»¤ìŠ¤í…€ ëª¨ë“œ
âœ… í•™ìƒ ì§„ë„ ëª¨ë‹ˆí„°ë§
âœ… ìë™ ì±„ì 
âœ… 7ì¼ ë¬´ë£Œ ì²´í—˜

ëŒ€ìƒ: ê°œì¸ ê³¼ì™¸ ì„ ìƒë‹˜, ì†Œê·œëª¨ í•™ì›
í•™ìƒ í”„ë¦¬ë¯¸ì—„ (Student Premium) - $19.99/ì›”
âœ… í•™ìƒ í”„ë¡œ ëª¨ë“  ê¸°ëŠ¥
âœ… AI ìƒì„± ë¬´ì œí•œ
âœ… Speaking í€´ì¦ˆ ë¬´ì œí•œ (GPT-4o ê³ í’ˆì§ˆ)
âœ… ìš°ì„  ì§€ì›
âŒ í•™ìƒ ê´€ë¦¬ ë¶ˆê°€

ëŒ€ìƒ: í—¤ë¹„ ìœ ì € í•™ìŠµì
ì„ ìƒë‹˜ í”„ë¦¬ë¯¸ì—„ (Teacher Premium) - $29.99/ì›”
âœ… ì„ ìƒë‹˜ í”„ë¡œ ëª¨ë“  ê¸°ëŠ¥
âœ… AI ìƒì„± ë¬´ì œí•œ
âœ… Speaking ë¬´ì œí•œ (GPT-4o ê³ í’ˆì§ˆ)
âœ… í•™ìƒ ë¬´ì œí•œ ê´€ë¦¬
âœ… ìš°ì„  ì§€ì› (24ì‹œê°„ ì´ë‚´ ì‘ë‹µ)
âœ… ê³ ê¸‰ ë¶„ì„ ë¦¬í¬íŠ¸

ëŒ€ìƒ: ëŒ€í˜• í•™ì›, ì˜¨ë¼ì¸ ê°•ì‚¬
ğŸ® í€´ì¦ˆ íƒ€ì… (6ê°€ì§€)
ê¸°ì¡´ í€´ì¦ˆ (4ê°œ)
Multiple Choice (ê°ê´€ì‹)
Dialogue Drag & Drop (ëŒ€í™” ë“œë˜ê·¸)
Fill in the Blank (ë¹ˆì¹¸ ì±„ìš°ê¸°)
Matching (ë‹¨ì–´ ë§¤ì¹­)
ì‹ ê·œ í€´ì¦ˆ (2ê°œ)
5. Sentence Drag & Drop (ë¬¸ì¥ ë“œë˜ê·¸)
ìœ ì§€ (ë‚˜ì¤‘ì„ ìœ„í•´)
6. Speaking (ë°œìŒ í€´ì¦ˆ) - 3ê°€ì§€ íƒ€ì…
Type 1: ëŒ€í™”ë¥¼ ë³´ê³  ë”°ë¼ ì½ê¸°
ì§€ë¬¸: "ì§ˆë¬¸ì„ ë”°ë¼ ì½ìœ¼ì„¸ìš”" ë˜ëŠ” "ëŒ€ë‹µì„ ë”°ë¼ ì½ìœ¼ì„¸ìš”"
í™”ë©´: Q: "ì–´ì œ ì–´ë””ì— ê°”ì–´ìš”?" 
      A: "ì €ëŠ” ì–´ì œ ë„ì„œê´€ì— ê°”ì–´ìš”."
ì‚¬ìš©ì: ğŸ¤ ë…¹ìŒ
í‰ê°€: Whisper APIë¡œ í…ìŠ¤íŠ¸ ë³€í™˜ â†’ ì •ë‹µ ë¹„êµ (O/X)
Type 2: ë“£ê³  ë”°ë¼ ë§í•˜ê¸°
ì§€ë¬¸: "ì˜¤ë””ì˜¤ë¥¼ ë“£ê³  ë”°ë¼ í•˜ì„¸ìš”"
í™”ë©´: ğŸ”Š ì˜¤ë””ì˜¤ ì¬ìƒ (ëŒ€í™” ìˆ¨ê¹€)
      "ì§ˆë¬¸ì„ ë”°ë¼ í•˜ì„¸ìš”" ë˜ëŠ” "ëŒ€ë‹µì„ ë”°ë¼ í•˜ì„¸ìš”"
ì‚¬ìš©ì: ğŸ¤ ë…¹ìŒ
í‰ê°€: Whisper APIë¡œ í…ìŠ¤íŠ¸ ë³€í™˜ â†’ ì •ë‹µ ë¹„êµ
Type 3: ë‹¨ì–´ë¥¼ ë³´ê³  ë¬¸ì¥ ë§Œë“¤ê¸°
ì§€ë¬¸: "ì œì‹œëœ ë‹¨ì–´ë¡œ ë¬¸ì¥ì„ ë§Œë“œì„¸ìš”"
í™”ë©´: Q: "ì–´ì œ ì–´ë””ì— ê°”ì–´ìš”?"
      ë‹¨ì–´: "ë„ì„œê´€"
      
ë˜ëŠ”
      Q: "ì–´ë””"
      A: "ì €ëŠ” ì–´ì œ ë„ì„œê´€ì— ê°”ì–´ìš”."
      
ì‚¬ìš©ì: ğŸ¤ ë…¹ìŒ
í‰ê°€: Whisper APIë¡œ í…ìŠ¤íŠ¸ ë³€í™˜ â†’ ì˜ë¯¸ ë¹„êµ (ìœ ì‚¬ë„ 80%)
TTS (Text-to-Speech):
Type 2ì—ì„œ ì˜¤ë””ì˜¤ ì¬ìƒìš©
OpenAI TTS API ì‚¬ìš© (tts-1 ëª¨ë¸)
ë¹„ìš©: $15 per 1M characters (~$0.000015/ë¬¸ì¥)
ğŸ¤– AI ì‹œìŠ¤í…œ ì„¤ê³„
AI ëª¨ë¸ ì „ëµ
GPT-4o mini (ì£¼ë ¥)
ìš©ë„: ëª¨ë“  ê¸°ë³¸ ë¬¸ì œ ìƒì„± (95%)
ë¹„ìš©: $0.15/$0.60 per 1M tokens
Speaking: í•™ìƒ/ì„ ìƒë‹˜ í”„ë¡œ
í’ˆì§ˆ: ìš°ìˆ˜ (í•™ìŠµìš© ì¶©ë¶„)
GPT-4o (í”„ë¦¬ë¯¸ì—„)
ìš©ë„: Speaking ê³ í’ˆì§ˆ ëŒ€í™” (5%)
ë¹„ìš©: $3/$10 per 1M tokens
Speaking: í”„ë¦¬ë¯¸ì—„ ì „ìš©
í’ˆì§ˆ: ìµœê³  (ì›ì–´ë¯¼ ìˆ˜ì¤€)
Claude Haiku 4.5 (ë°±ì—…)
ìš©ë„: GPT ì‹¤íŒ¨ ì‹œ Fallback
ë¹„ìš©: $1/$5 per 1M tokens
Speaking ë¬¸ì œ ì‚¬ì „ ìƒì„±
ê°œìˆ˜:
í˜„ì¬: 31ê°œ ë¬¸ë²• Ã— 30ê°œ = 930ê°œ
ê° ë¬¸ë²•ë‹¹ 3ê°€ì§€ íƒ€ì… Ã— 10ê°œì”©
íƒ€ì…ë³„ ë¶„ë°° (ë¬¸ë²•ë‹¹):
Type 1 (ë”°ë¼ ì½ê¸°): 10ê°œ
Type 2 (ë“£ê³  ë”°ë¼ í•˜ê¸°): 10ê°œ
Type 3 (ë‹¨ì–´ë¡œ ë¬¸ì¥ ë§Œë“¤ê¸°): 10ê°œ
TTS ì˜¤ë””ì˜¤ ìƒì„±:
Type 2ìš© ì˜¤ë””ì˜¤ ë¯¸ë¦¬ ìƒì„±
31 ë¬¸ë²• Ã— 10ê°œ Ã— 2ê°œ(Q+A) = 620ê°œ ì˜¤ë””ì˜¤
ë¹„ìš©: 620 Ã— $0.000015 = ~$0.01 (ë¬´ì‹œ ê°€ëŠ¥)
ì´ˆê¸° ìƒì„± ë¹„ìš©:
930ê°œ Ã— $0.00026 = $0.24 (1íšŒì„±)
ë°ì´í„°ë² ì´ìŠ¤:
CREATE TABLE pre_generated_speaking_problems (
  id UUID PRIMARY KEY,
  grammar_name VARCHAR(100),
  speaking_type VARCHAR(20), -- 'read_aloud', 'listen_repeat', 'word_prompt'
  question TEXT,
  answer TEXT,
  prompt_word TEXT, -- Type 3ìš© ë‹¨ì–´
  question_translation TEXT,
  answer_translation TEXT,
  audio_url TEXT, -- Type 2ìš© TTS ì˜¤ë””ì˜¤
  difficulty_level INTEGER,
  created_at TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_speaking_grammar ON pre_generated_speaking_problems(grammar_name);
CREATE INDEX idx_speaking_type ON pre_generated_speaking_problems(speaking_type);
ğŸ“š ê°„ë‹¨ ëª¨ë“œ (Simple Mode)
UI Flow
1. ë ˆë²¨/ë¬¸ë²• ì„ íƒ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ê°„ë‹¨ ëª¨ë“œ - ì—°ìŠµí•˜ê¸°                  â”‚
â”‚                                     â”‚
â”‚ ì–´ë””ê¹Œì§€ ê³µë¶€í•˜ì…¨ë‚˜ìš”?                â”‚
â”‚                                     â”‚
â”‚ â—‹ A1: Beginner â–¼                    â”‚
â”‚   â”œâ”€ â–¡ ì€/ëŠ”, ì´ì—ìš”/ì˜ˆìš”            â”‚
â”‚   â”œâ”€ â–¡ ì´ê±°, ê·¸ê±°, ì €ê±°              â”‚
â”‚   ...                               â”‚
â”‚   â””â”€ â— ì•˜ì–´ìš”/ì—ˆì–´ìš” âœ“               â”‚
â”‚                                     â”‚
â”‚ â—‹ A2: Elementary â–¼ (ì¶”í›„ ì¶”ê°€)      â”‚
â”‚ â—‹ B1~C2 (ì¶”í›„ ì¶”ê°€)                 â”‚
â”‚                                     â”‚
â”‚ [ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ìƒì„±í•˜ê¸°]              â”‚
â”‚ [âš™ï¸ ê³ ê¸‰ ì„¤ì •]                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2. ê¸°ë³¸ ì„¤ì • (ìë™)
ì„ íƒí•œ ë¬¸ë²•ê¹Œì§€ ê° íƒ€ì… 10ê°œì”© ìë™ ìƒì„±
Speaking 10ê°œ (3ê°€ì§€ íƒ€ì… ê³¨ê³ ë£¨)
ì´ 50ê°œ ë¬¸ì œ
3. ê³ ê¸‰ ì„¤ì • (ì‚¬ìš©ì ì„ íƒ)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ í€´ì¦ˆ ê°œìˆ˜ë¥¼ ì„ íƒí•˜ì„¸ìš” (ê° ìµœëŒ€ 20ê°œ) â”‚
â”‚                                     â”‚
â”‚ Matching:           [10] ê°œ         â”‚
â”‚ Multiple Choice:    [10] ê°œ         â”‚
â”‚ Dialogue Drag&Drop: [10] ê°œ         â”‚
â”‚ Fill-in-blank:      [10] ê°œ         â”‚
â”‚ Speaking:           [10] ê°œ         â”‚
â”‚                                     â”‚
â”‚ [ìƒì„±í•˜ê¸°]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ìŠ¤ë§ˆíŠ¸ ë¬¸ì œ ì„ íƒ ì•Œê³ ë¦¬ì¦˜
// ê°„ë‹¨ ëª¨ë“œ ë¬¸ì œ ì„ íƒ
async function selectProblemsForSimpleMode(
  grammarEnd: string,
  quizCounts: QuizCounts
) {
  // 1. ì„ íƒí•œ ë¬¸ë²•ê¹Œì§€ì˜ ë¦¬ìŠ¤íŠ¸
  const grammarList = getGrammarsUpTo(grammarEnd);
  // ['introduction', 'demonstratives', ..., 'past-tense']
  
  // 2. AIë¡œ ê°€ì¤‘ì¹˜ ê³„ì‚° (ìºì‹±)
  const cacheKey = `weights_${grammarList.join('_')}`;
  let weights = cache.get(cacheKey);
  
  if (!weights) {
    weights = await calculateGrammarWeights(grammarList);
    // { introduction: 5, demonstratives: 8, ..., past-tense: 30 }
    cache.set(cacheKey, weights, { ttl: 86400 }); // 24ì‹œê°„
  }
  
  // 3. ê° í€´ì¦ˆ íƒ€ì…ë³„ ë¬¸ì œ ì„ íƒ
  const selectedProblems = {};
  
  for (const [quizType, count] of Object.entries(quizCounts)) {
    const problems = [];
    
    for (const grammar of grammarList) {
      const problemCount = Math.ceil(count * weights[grammar] / 100);
      
      // ê¸°ì¡´ ë¬¸ì œì—ì„œ ëœë¤ ì„ íƒ
      if (quizType === 'speaking') {
        const available = await getPreGeneratedSpeaking(grammar);
        problems.push(...shuffle(available).slice(0, problemCount));
      } else {
        const available = await getExistingProblems(grammar, quizType);
        problems.push(...shuffle(available).slice(0, problemCount));
      }
    }
    
    selectedProblems[quizType] = shuffle(problems).slice(0, count);
  }
  
  return selectedProblems;
}

// AI ê°€ì¤‘ì¹˜ ê³„ì‚° (GPT-4o mini)
async function calculateGrammarWeights(grammarList: string[]) {
  const response = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [{
      role: 'user',
      content: `í•œêµ­ì–´ ë¬¸ë²• ìˆœì„œ: ${grammarList.join(' â†’ ')}
      
ë³µìŠµ ë¬¸ì œ ë¶„ë°° ë¹„ìœ¨ì„ ê³„ì‚°í•´ì£¼ì„¸ìš”.
- ìµœê·¼ ë¬¸ë²•ì¼ìˆ˜ë¡ ë†’ì€ ë¹„ìœ¨ (ì–´ë ¤ì›€, ë” ë§ì€ ì—°ìŠµ í•„ìš”)
- ì´ˆë°˜ ë¬¸ë²•ì€ ë‚®ì€ ë¹„ìœ¨ (ì‰¬ì›€, ë³µìŠµìš©)
- ì´í•© 100%

JSON í˜•ì‹: {"introduction": 5, "demonstratives": 8, ...}`
    }],
    response_format: { type: 'json_object' }
  });
  
  return JSON.parse(response.choices[0].message.content);
}
ğŸ¨ ì»¤ìŠ¤í…€ ëª¨ë“œ (Custom Mode)
UI Flow (4ë‹¨ê³„)
Step 1: ì–´íœ˜ ì¶”ê°€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì»¤ìŠ¤í…€ ëª¨ë“œ - 1/4                    â”‚
â”‚                                     â”‚
â”‚ ì–´íœ˜ë¥¼ ì¶”ê°€í•˜ì„¸ìš” (í•œêµ­ì–´ë§Œ ì…ë ¥)      â”‚
â”‚                                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ê¸¸ì„ ìƒì–´ë²„ë¦¬ë‹¤, ì ì´ ì˜¤ë‹¤,       â”‚ â”‚
â”‚ â”‚ ì ì„ ëª» ìë‹¤, ì•‰ë‹¤, ëŠ¦ë‹¤          â”‚ â”‚
â”‚ â”‚                                 â”‚ â”‚
â”‚ â”‚ * ë‹¨ì–´, í‘œí˜„, ê´€ìš©êµ¬ ëª¨ë‘ ì…ë ¥    â”‚ â”‚
â”‚ â”‚ * AIê°€ ìë™ìœ¼ë¡œ ì˜ì–´ ë²ˆì—­ ìƒì„±    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”‚ [ë‹¤ìŒ]                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Step 2: ë¬¸ë²• ì„ íƒ (ì²´í¬ë°•ìŠ¤)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì»¤ìŠ¤í…€ ëª¨ë“œ - 2/4                    â”‚
â”‚                                     â”‚
â”‚ ì‚¬ìš©í•  ë¬¸ë²•ì„ ì„ íƒí•˜ì„¸ìš”              â”‚
â”‚                                     â”‚
â”‚ A1: Beginner â–¼                      â”‚
â”‚   â˜‘ ì€/ëŠ”, ì´ì—ìš”/ì˜ˆìš”               â”‚
â”‚   â˜ ì´ê±°, ê·¸ê±°, ì €ê±°                â”‚
â”‚   â˜‘ ì´/ê°€ ì•„ë‹ˆì—ìš”                  â”‚
â”‚   ...                               â”‚
â”‚   â˜‘ ì•˜ì–´ìš”/ì—ˆì–´ìš”                   â”‚
â”‚                                     â”‚
â”‚ A2: Elementary â–¼ (ì¶”í›„ ì¶”ê°€)        â”‚
â”‚                                     â”‚
â”‚ * ìˆœì„œëŠ” ìœ ì§€ë˜ì§€ë§Œ ì„ íƒì€ ììœ ë¡­ê²Œ   â”‚
â”‚                                     â”‚
â”‚ [ì´ì „] [ë‹¤ìŒ]                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Step 3: í€´ì¦ˆ íƒ€ì… ë° ê°œìˆ˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì»¤ìŠ¤í…€ ëª¨ë“œ - 3/4                    â”‚
â”‚                                     â”‚
â”‚ í€´ì¦ˆ ê°œìˆ˜ë¥¼ ì„ íƒí•˜ì„¸ìš” (ê° ìµœëŒ€ 20ê°œ) â”‚
â”‚                                     â”‚
â”‚ Matching:           [5] ê°œ          â”‚
â”‚ Multiple Choice:    [10] ê°œ         â”‚
â”‚ Dialogue Drag&Drop: [10] ê°œ         â”‚
â”‚ Fill-in-blank:      [5] ê°œ          â”‚
â”‚ Speaking:           [10] ê°œ ğŸ”’      â”‚
â”‚                                     â”‚
â”‚ ì´ AI ìƒì„± ë¬¸ì œ: 40ê°œ                â”‚
â”‚ (ë‚¨ì€ ìƒì„± íšŸìˆ˜: ë¬´ë£Œ ì£¼0íšŒ/í”„ë¡œ ì›”17íšŒ)â”‚
â”‚                                     â”‚
â”‚ [ì´ì „] [AI ìƒì„±í•˜ê¸°]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Step 4: ë¯¸ë¦¬ë³´ê¸° ë° ìˆ˜ì •
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì»¤ìŠ¤í…€ ëª¨ë“œ - 4/4                    â”‚
â”‚                                     â”‚
â”‚ ìƒì„±ëœ ë¬¸ì œ ë¯¸ë¦¬ë³´ê¸°                  â”‚
â”‚                                     â”‚
â”‚ â”Œâ”€ Multiple Choice #1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Q: ì–´ì œ ì™œ íšŒì‚¬ì— ëŠ¦ì—ˆì–´ìš”?       â”‚ â”‚
â”‚ â”‚ A: ë¯¸ì•ˆí•´ìš”. ì ì„ ëª» ì¤ì–´ìš”.      â”‚ â”‚
â”‚ â”‚ ...                             â”‚ â”‚
â”‚ â”‚ [ğŸ”„ ë‹¤ì‹œ ìƒì„±] [âœï¸ ìˆ˜ì •]         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                     â”‚
â”‚ ... (40ê°œ ë¬¸ì œ)                     â”‚
â”‚                                     â”‚
â”‚ [ì „ì²´ ë‹¤ì‹œ ìƒì„±] [ì´ì „] [ì™„ë£Œ]        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
AI ìƒì„± ë¡œì§
async function generateCustomProblems(
  vocabulary: string[],
  grammars: string[],
  quizCounts: QuizCounts,
  userTier: 'free' | 'pro' | 'premium'
) {
  // 1. ì‚¬ìš©ëŸ‰ ì²´í¬
  const usage = await checkAIGenerationLimit(userId);
  if (!usage.allowed) {
    throw new Error('AI ìƒì„± íšŸìˆ˜ ì´ˆê³¼');
  }
  
  // 2. ì–´íœ˜ ë²ˆì—­ ìƒì„± (Matchingìš©)
  const translatedVocab = await translateVocabulary(vocabulary);
  // { "ê¸¸ì„ ìƒì–´ë²„ë¦¬ë‹¤": "to get lost", ... }
  
  // 3. ê° í€´ì¦ˆ íƒ€ì…ë³„ ë¬¸ì œ ìƒì„±
  const problems = {};
  
  for (const [quizType, count] of Object.entries(quizCounts)) {
    if (count === 0) continue;
    
    const model = (userTier === 'premium' && quizType === 'speaking') 
      ? 'gpt-4o' 
      : 'gpt-4o-mini';
    
    problems[quizType] = await generateQuizProblems({
      type: quizType,
      vocabulary,
      grammars,
      count,
      model
    });
  }
  
  // 4. ì‚¬ìš©ëŸ‰ ê¸°ë¡
  await trackAIUsage(userId, 1); // 1íšŒ ìƒì„±
  
  return problems;
}

// ê°œë³„ ë¬¸ì œ ì¬ìƒì„±
async function regenerateSingleProblem(
  problemId: string,
  context: GenerationContext
) {
  const problem = await generateQuizProblems({
    ...context,
    count: 1
  });
  
  return problem[0];
}

// ìˆ˜ë™ í¸ì§‘
async function editProblem(problemId: string, updates: Partial<Problem>) {
  return await updateProblem(problemId, updates);
}
ğŸ‘¥ ì„ ìƒë‹˜-í•™ìƒ í”Œë«í¼
í•™ìƒ ì´ˆëŒ€ ì‹œìŠ¤í…œ
ë°©ë²• 1: ì´ë©”ì¼ ì´ˆëŒ€
async function inviteStudentByEmail(
  teacherId: string,
  studentEmail: string
) {
  // 1. í•™ìƒ ìˆ˜ ì œí•œ í™•ì¸
  const limit = await checkStudentManagementLimit(teacherId);
  if (!limit.allowed) {
    throw new Error(`í•™ìƒ ì œí•œ ì´ˆê³¼ (${limit.current}/${limit.max}ëª…)`);
  }
  
  // 2. ì´ˆëŒ€ ìƒì„±
  const invitation = await createInvitation({
    teacher_id: teacherId,
    student_email: studentEmail,
    expires_at: addDays(new Date(), 7) // 7ì¼ ìœ íš¨
  });
  
  // 3. ì´ë©”ì¼ ë°œì†¡
  await sendEmail({
    to: studentEmail,
    subject: 'ë°”ë‚˜ë‚˜ ì½”ë¦¬ì•ˆ ì´ˆëŒ€ì¥',
    template: 'teacher_invitation',
    data: {
      teacherName: await getTeacherName(teacherId),
      invitationLink: `${BASE_URL}/accept-invitation/${invitation.id}`
    }
  });
  
  return invitation;
}

// í•™ìƒì´ ì´ˆëŒ€ ìˆ˜ë½
async function acceptInvitation(invitationId: string, studentId: string) {
  const invitation = await getInvitation(invitationId);
  
  // ê²€ì¦
  if (invitation.expires_at < new Date()) {
    throw new Error('ì´ˆëŒ€ê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
  }
  
  // ê´€ê³„ ìƒì„±
  await createTeacherStudentRelation({
    teacher_id: invitation.teacher_id,
    student_id: studentId,
    status: 'active'
  });
  
  // ì´ˆëŒ€ ì‚­ì œ
  await deleteInvitation(invitationId);
}
ë°©ë²• 2: ì´ˆëŒ€ ì½”ë“œ
async function generateInvitationCode(teacherId: string) {
  const code = generateRandomCode(8); // "ABC12345"
  
  await createInvitationCode({
    teacher_id: teacherId,
    code,
    expires_at: addDays(new Date(), 30), // 30ì¼ ìœ íš¨
    max_uses: 30 // ìµœëŒ€ 30ëª…
  });
  
  return code;
}

// í•™ìƒì´ ê°€ì… ì‹œ ì½”ë“œ ì…ë ¥
async function joinByInvitationCode(code: string, studentId: string) {
  const invitation = await getInvitationByCode(code);
  
  if (!invitation || invitation.expires_at < new Date()) {
    throw new Error('ìœ íš¨í•˜ì§€ ì•Šì€ ì´ˆëŒ€ ì½”ë“œì…ë‹ˆë‹¤');
  }
  
  if (invitation.used_count >= invitation.max_uses) {
    throw new Error('ì´ˆëŒ€ ì½”ë“œ ì‚¬ìš© íšŸìˆ˜ê°€ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤');
  }
  
  await createTeacherStudentRelation({
    teacher_id: invitation.teacher_id,
    student_id: studentId,
    status: 'active'
  });
  
  await incrementCodeUsage(invitation.id);
}
í•™ìƒ ì œí•œ
ê·œì¹™:
í•™ìƒì€ 1ëª…ì˜ ì„ ìƒë‹˜ë§Œ ê°€ì§ˆ ìˆ˜ ìˆìŒ
ì„ ìƒë‹˜ì„ ë°”ê¾¸ë ¤ë©´ ê¸°ì¡´ ê´€ê³„ ì¢…ë£Œ í•„ìš”
async function checkStudentTeacher(studentId: string) {
  const relation = await getActiveTeacherRelation(studentId);
  
  if (relation) {
    return {
      hasTeacher: true,
      teacherId: relation.teacher_id,
      teacherName: await getTeacherName(relation.teacher_id)
    };
  }
  
  return { hasTeacher: false };
}

// ê´€ê³„ ì¢…ë£Œ
async function leaveTeacher(studentId: string, teacherId: string) {
  await updateTeacherStudentRelation({
    teacher_id: teacherId,
    student_id: studentId,
    status: 'inactive'
  });
}
ğŸ“ ìˆ™ì œ ì‹œìŠ¤í…œ
ìˆ™ì œ ìƒì„± Flow
ì„ ìƒë‹˜ â†’ í•™ìƒ ìˆ™ì œ ë¶€ì—¬:
async function createAndAssignHomework(
  teacherId: string,
  students: string[],
  homework: HomeworkData
) {
  // 1. ìˆ™ì œ ìƒì„± (ê°„ë‹¨/ì»¤ìŠ¤í…€ ëª¨ë“œ)
  const assignment = await createAssignment({
    teacher_id: teacherId,
    title: homework.title,
    description: homework.description,
    assignment_type: homework.type, // 'simple' or 'custom'
    
    // Simple mode
    selected_level: homework.level,
    selected_grammar_end: homework.grammarEnd,
    
    // Custom mode
    custom_vocabulary: homework.vocabulary,
    selected_grammars: homework.grammars,
    
    quiz_type_counts: homework.quizCounts,
    due_date: homework.dueDate
  });
  
  // 2. ë¬¸ì œ ìƒì„± (ê°„ë‹¨ ëª¨ë“œëŠ” ê¸°ì¡´ ë¬¸ì œ, ì»¤ìŠ¤í…€ì€ AI)
  let problems;
  if (homework.type === 'simple') {
    problems = await selectProblemsForSimpleMode(
      homework.grammarEnd,
      homework.quizCounts
    );
  } else {
    problems = await generateCustomProblems(
      homework.vocabulary,
      homework.grammars,
      homework.quizCounts,
      await getUserTier(teacherId)
    );
  }
  
  // 3. ë¬¸ì œ ì €ì¥
  await saveAssignmentProblems(assignment.id, problems);
  
  // 4. í•™ìƒë“¤ì—ê²Œ ë¶€ì—¬
  for (const studentId of students) {
    await createStudentAssignment({
      assignment_id: assignment.id,
      student_id: studentId,
      assigned_at: new Date()
    });
    
    // ì•Œë¦¼ ì „ì†¡
    await sendNotification(studentId, {
      type: 'new_homework',
      title: 'ìƒˆ ìˆ™ì œê°€ ë„ì°©í–ˆì–´ìš”!',
      message: `${homework.title} - ë§ˆê°: ${format(homework.dueDate)}`
    });
  }
  
  return assignment;
}
ìˆ™ì œ ì œì¶œ ë° ì±„ì 
// í•™ìƒì´ ìˆ™ì œ ì‹œì‘
async function startHomework(studentAssignmentId: string) {
  await updateStudentAssignment(studentAssignmentId, {
    started_at: new Date(),
    status: 'in_progress'
  });
}

// í•™ìƒì´ ë¬¸ì œ í’€ì´
async function submitAnswer(
  studentAssignmentId: string,
  problemId: string,
  userAnswer: string
) {
  const problem = await getAssignmentProblem(problemId);
  const isCorrect = checkAnswer(problem, userAnswer);
  
  // ì‹œë„ ê¸°ë¡
  await createAttempt({
    student_assignment_id: studentAssignmentId,
    problem_id: problemId,
    user_answer: userAnswer,
    is_correct: isCorrect,
    time_spent: getTimeSpent()
  });
  
  return { isCorrect };
}

// ìˆ™ì œ ì œì¶œ (ìë™ ì±„ì )
async function submitHomework(studentAssignmentId: string) {
  const attempts = await getAttempts(studentAssignmentId);
  
  const score = attempts.filter(a => a.is_correct).length;
  const total = attempts.length;
  
  await updateStudentAssignment(studentAssignmentId, {
    completed_at: new Date(),
    status: 'completed',
    score,
    total_questions: total
  });
  
  // ì„ ìƒë‹˜ì—ê²Œ ì•Œë¦¼
  const assignment = await getStudentAssignment(studentAssignmentId);
  await sendNotification(assignment.teacher_id, {
    type: 'homework_completed',
    message: `${await getStudentName(assignment.student_id)}ë‹˜ì´ ìˆ™ì œë¥¼ ì œì¶œí–ˆìŠµë‹ˆë‹¤. (ì ìˆ˜: ${score}/${total})`
  });
  
  return { score, total };
}
ìˆ™ì œ ì¬ì‹œë„
// ì¬ì‹œë„ (ì ìˆ˜ ê°±ì‹  ì•ˆ ë¨)
async function retryHomework(studentAssignmentId: string) {
  const assignment = await getStudentAssignment(studentAssignmentId);
  
  if (assignment.status !== 'completed') {
    throw new Error('ì•„ì§ ì œì¶œí•˜ì§€ ì•Šì€ ìˆ™ì œì…ë‹ˆë‹¤');
  }
  
  // ìƒˆ ì‹œë„ ì„¸ì…˜ ìƒì„±
  const retrySession = await createRetrySession({
    student_assignment_id: studentAssignmentId,
    attempted_at: new Date()
  });
  
  return retrySession;
}

// ì¬ì‹œë„ ì‹œ ê¸°ë¡ì€ ë‚¨ì§€ë§Œ ì ìˆ˜ëŠ” ë³€ê²½ ì•ˆ ë¨
async function submitRetryAnswer(
  retrySessionId: string,
  problemId: string,
  userAnswer: string
) {
  const problem = await getAssignmentProblem(problemId);
  const isCorrect = checkAnswer(problem, userAnswer);
  
  await createRetryAttempt({
    retry_session_id: retrySessionId,
    problem_id: problemId,
    user_answer: userAnswer,
    is_correct: isCorrect
  });
  
  return { isCorrect };
}
ë§ˆê°ì¼ ë° ì—°ì¥
// ë§ˆê°ì¼ ì²´í¬
async function canSubmitHomework(studentAssignmentId: string) {
  const assignment = await getStudentAssignment(studentAssignmentId);
  const homework = await getAssignment(assignment.assignment_id);
  
  if (new Date() > homework.due_date) {
    return {
      allowed: false,
      message: 'ë§ˆê°ì¼ì´ ì§€ë‚¬ìŠµë‹ˆë‹¤'
    };
  }
  
  return { allowed: true };
}

// ì„ ìƒë‹˜ì´ ë§ˆê°ì¼ ì—°ì¥
async function extendDueDate(
  assignmentId: string,
  newDueDate: Date
) {
  await updateAssignment(assignmentId, {
    due_date: newDueDate
  });
  
  // í•™ìƒë“¤ì—ê²Œ ì•Œë¦¼
  const students = await getAssignedStudents(assignmentId);
  for (const student of students) {
    await sendNotification(student.id, {
      type: 'due_date_extended',
      message: `ë§ˆê°ì¼ì´ ${format(newDueDate)}ë¡œ ì—°ì¥ë˜ì—ˆìŠµë‹ˆë‹¤`
    });
  }
}
ğŸ“± PWA (Progressive Web App)
ì„¤ì •
// next.config.js
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
  disable: process.env.NODE_ENV === 'development'
});

module.exports = withPWA({
  // ... ê¸°ì¡´ ì„¤ì •
});
// public/manifest.json
{
  "name": "Banana Korean",
  "short_name": "BananaKR",
  "description": "AI-powered Korean learning platform",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#FFC107",
  "icons": [
    {
      "src": "/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
ì˜¤í”„ë¼ì¸ ì§€ì›
// Service Workerë¡œ ë¬¸ì œ ìºì‹±
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/problems/')) {
    event.respondWith(
      caches.match(event.request).then((response) => {
        return response || fetch(event.request).then((fetchResponse) => {
          return caches.open('problems-cache').then((cache) => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});

// ì˜¤í”„ë¼ì¸ ì‹œ ë¡œì»¬ DBì— ë‹µì•ˆ ì €ì¥
async function submitAnswerOffline(problemId: string, answer: string) {
  await localDB.pendingAnswers.add({
    problemId,
    answer,
    timestamp: new Date(),
    synced: false
  });
}

// ì˜¨ë¼ì¸ ë³µê·€ ì‹œ ë™ê¸°í™”
window.addEventListener('online', async () => {
  const pending = await localDB.pendingAnswers.where('synced').equals(false).toArray();
  
  for (const answer of pending) {
    await submitAnswer(answer.problemId, answer.answer);
    await localDB.pendingAnswers.update(answer.id, { synced: true });
  }
});
ğŸ’° ê²°ì œ ì‹œìŠ¤í…œ
Stripe (êµ­ì œ ê²°ì œ)
// ì²´í¬ì•„ì›ƒ ì„¸ì…˜ ìƒì„±
async function createStripeCheckout(
  userId: string,
  plan: 'student_pro' | 'teacher_pro' | 'student_premium' | 'teacher_premium',
  trial: boolean = true
) {
  const priceId = STRIPE_PRICES[plan];
  
  const session = await stripe.checkout.sessions.create({
    customer_email: await getUserEmail(userId),
    line_items: [{ price: priceId, quantity: 1 }],
    mode: 'subscription',
    
    // 7ì¼ ë¬´ë£Œ ì²´í—˜
    ...(trial && {
      subscription_data: {
        trial_period_days: 7
      }
    }),
    
    success_url: `${BASE_URL}/subscription/success`,
    cancel_url: `${BASE_URL}/subscription/cancel`,
    metadata: { user_id: userId, plan }
  });
  
  return session.url;
}

// Webhook ì²˜ë¦¬
async function handleStripeWebhook(event: Stripe.Event) {
  switch (event.type) {
    case 'checkout.session.completed': {
      const session = event.data.object;
      const { user_id, plan } = session.metadata;
      
      await createSubscription(user_id, plan, {
        stripe_subscription_id: session.subscription,
        stripe_customer_id: session.customer,
        trial_end: addDays(new Date(), 7)
      });
      break;
    }
    
    case 'customer.subscription.deleted': {
      const subscription = event.data.object;
      await cancelSubscription(subscription.metadata.user_id);
      break;
    }
  }
}
Toss Payments (í•œêµ­ ê²°ì œ)
// Toss ê²°ì œ ìš”ì²­
async function createTossPayment(
  userId: string,
  plan: string,
  trial: boolean = true
) {
  const amount = PLAN_PRICES[plan];
  
  const payment = await tossPayments.requestPayment('ì¹´ë“œ', {
    amount: trial ? 0 : amount, // ì²´í—˜ì€ 0ì›
    orderId: generateOrderId(),
    orderName: `ë°”ë‚˜ë‚˜ ì½”ë¦¬ì•ˆ ${plan}`,
    customerEmail: await getUserEmail(userId),
    successUrl: `${BASE_URL}/payment/success`,
    failUrl: `${BASE_URL}/payment/fail`,
    metadata: { user_id: userId, plan, trial }
  });
  
  return payment;
}

// ì •ê¸° ê²°ì œ (ë¹Œë§í‚¤)
async function setupRecurringPayment(userId: string, billingKey: string) {
  await saveBillingKey(userId, billingKey);
  
  // ë§¤ì›” 1ì¼ ìë™ ê²°ì œ
  scheduleMonthlyPayment(userId);
}
í™˜ë¶ˆ ì²˜ë¦¬
// 7ì¼ ì´ë‚´ ì „ì•¡ í™˜ë¶ˆ
async function requestRefund(userId: string) {
  const subscription = await getSubscription(userId);
  
  const daysSinceStart = differenceInDays(
    new Date(),
    subscription.created_at
  );
  
  if (daysSinceStart > 7) {
    throw new Error('í™˜ë¶ˆ ê°€ëŠ¥ ê¸°ê°„(7ì¼)ì´ ì§€ë‚¬ìŠµë‹ˆë‹¤');
  }
  
  // Stripe í™˜ë¶ˆ
  if (subscription.stripe_subscription_id) {
    await stripe.subscriptions.cancel(subscription.stripe_subscription_id);
    await stripe.refunds.create({
      payment_intent: subscription.stripe_payment_intent_id
    });
  }
  
  // Toss í™˜ë¶ˆ
  if (subscription.toss_payment_key) {
    await tossPayments.cancelPayment(subscription.toss_payment_key, {
      cancelReason: 'ê³ ê° ìš”ì²­'
    });
  }
  
  await updateSubscription(userId, {
    status: 'refunded',
    tier: 'free'
  });
}
ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ (ì™„ì „íŒ)
-- 1. í”„ë¡œí•„ (ì—­í•  ì¶”ê°€)
ALTER TABLE profiles ADD COLUMN user_role VARCHAR(20) NOT NULL;
-- 'student' or 'teacher'

-- 2. êµ¬ë… (ì—­í• ë³„ ë¶„ë¦¬)
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  tier VARCHAR(30), -- 'free', 'student_pro', 'teacher_pro', 'student_premium', 'teacher_premium'
  
  -- Stripe
  stripe_customer_id VARCHAR(255),
  stripe_subscription_id VARCHAR(255),
  
  -- Toss Payments
  toss_billing_key VARCHAR(255),
  toss_customer_key VARCHAR(255),
  
  -- Limits
  max_students INTEGER, -- NULL=ê´€ë¦¬ ë¶ˆê°€, 0=í”„ë¦¬, 30=í”„ë¡œ, NULL=í”„ë¦¬ë¯¸ì—„ ë¬´ì œí•œ
  monthly_ai_generations INTEGER, -- NULL=ë¬´ë£Œ, 20=í”„ë¡œ, NULL=í”„ë¦¬ë¯¸ì—„
  weekly_ai_generations INTEGER, -- 1=ë¬´ë£Œ, NULL=ê¸°íƒ€
  speaking_model VARCHAR(20), -- NULL=ë¶ˆê°€, 'gpt-4o-mini'=í”„ë¡œ, 'gpt-4o'=í”„ë¦¬ë¯¸ì—„
  
  -- Trial
  trial_end TIMESTAMP,
  
  -- Status
  status VARCHAR(20), -- 'active', 'canceled', 'refunded'
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 3. AI ì‚¬ìš©ëŸ‰ ì¶”ì 
CREATE TABLE user_ai_usage (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  period_type VARCHAR(10), -- 'week' or 'month'
  period_start DATE,
  
  ai_generations_used INTEGER DEFAULT 0,
  speaking_problems_generated INTEGER DEFAULT 0,
  
  last_generation_at TIMESTAMP,
  
  UNIQUE(user_id, period_type, period_start)
);

-- 4. Speaking ì‚¬ì „ ìƒì„± ë¬¸ì œ
CREATE TABLE pre_generated_speaking_problems (
  id UUID PRIMARY KEY,
  grammar_name VARCHAR(100),
  speaking_type VARCHAR(20), -- 'read_aloud', 'listen_repeat', 'word_prompt'
  question TEXT,
  answer TEXT,
  prompt_word TEXT, -- Type 3ìš©
  question_translation TEXT,
  answer_translation TEXT,
  audio_url TEXT, -- Type 2ìš© TTS
  difficulty_level INTEGER,
  created_at TIMESTAMP,
  
  INDEX idx_grammar (grammar_name),
  INDEX idx_type (speaking_type)
);

-- 5. Assignments (ìˆ™ì œ)
CREATE TABLE assignments (
  id UUID PRIMARY KEY,
  teacher_id UUID REFERENCES auth.users(id),
  title VARCHAR(255),
  description TEXT,
  assignment_type VARCHAR(20), -- 'simple' or 'custom'
  
  -- Simple Mode
  selected_level VARCHAR(10),
  selected_grammar_end VARCHAR(100),
  
  -- Custom Mode
  custom_vocabulary TEXT[],
  selected_grammars TEXT[],
  
  -- Quiz counts
  quiz_type_counts JSONB,
  
  -- Deadline
  due_date TIMESTAMP,
  
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- 6. Assignment Problems (ìƒì„±ëœ ë¬¸ì œ)
CREATE TABLE assignment_problems (
  id UUID PRIMARY KEY,
  assignment_id UUID REFERENCES assignments(id) ON DELETE CASCADE,
  problem_type VARCHAR(50),
  problem_data JSONB,
  order_index INTEGER,
  created_at TIMESTAMP,
  
  INDEX idx_assignment (assignment_id)
);

-- 7. Student Assignments (í•™ìƒë³„ ìˆ™ì œ)
CREATE TABLE student_assignments (
  id UUID PRIMARY KEY,
  assignment_id UUID REFERENCES assignments(id) ON DELETE CASCADE,
  student_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  assigned_at TIMESTAMP,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  
  score INTEGER,
  total_questions INTEGER,
  time_spent INTEGER,
  status VARCHAR(20), -- 'pending', 'in_progress', 'completed'
  
  UNIQUE(assignment_id, student_id)
);

-- 8. Student Assignment Attempts (ë¬¸ì œë³„ ì‹œë„)
CREATE TABLE student_assignment_attempts (
  id UUID PRIMARY KEY,
  student_assignment_id UUID REFERENCES student_assignments(id) ON DELETE CASCADE,
  problem_id UUID REFERENCES assignment_problems(id),
  user_answer TEXT,
  is_correct BOOLEAN,
  time_spent INTEGER,
  created_at TIMESTAMP,
  
  INDEX idx_student_assignment (student_assignment_id)
);

-- 9. Retry Sessions (ì¬ì‹œë„)
CREATE TABLE retry_sessions (
  id UUID PRIMARY KEY,
  student_assignment_id UUID REFERENCES student_assignments(id),
  attempted_at TIMESTAMP
);

CREATE TABLE retry_attempts (
  id UUID PRIMARY KEY,
  retry_session_id UUID REFERENCES retry_sessions(id),
  problem_id UUID,
  user_answer TEXT,
  is_correct BOOLEAN,
  created_at TIMESTAMP
);

-- 10. Teacher-Student Relationship
CREATE TABLE teacher_students (
  id UUID PRIMARY KEY,
  teacher_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  student_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  enrolled_at TIMESTAMP,
  status VARCHAR(20) DEFAULT 'active', -- 'active', 'inactive'
  
  UNIQUE(teacher_id, student_id),
  
  CHECK (
    EXISTS (
      SELECT 1 FROM profiles 
      WHERE id = teacher_id AND user_role = 'teacher'
    )
  ),
  CHECK (
    NOT EXISTS (
      SELECT 1 FROM teacher_students ts2
      WHERE ts2.student_id = student_id 
        AND ts2.status = 'active'
        AND ts2.id != id
    )
  ) -- í•™ìƒì€ 1ëª…ì˜ ì„ ìƒë‹˜ë§Œ
);

-- 11. Invitations (ì´ˆëŒ€)
CREATE TABLE invitations (
  id UUID PRIMARY KEY,
  teacher_id UUID REFERENCES auth.users(id),
  student_email VARCHAR(255),
  expires_at TIMESTAMP,
  created_at TIMESTAMP
);

CREATE TABLE invitation_codes (
  id UUID PRIMARY KEY,
  teacher_id UUID REFERENCES auth.users(id),
  code VARCHAR(20) UNIQUE,
  expires_at TIMESTAMP,
  max_uses INTEGER,
  used_count INTEGER DEFAULT 0,
  created_at TIMESTAMP
);

-- 12. Notifications (ì•Œë¦¼)
CREATE TABLE notifications (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  type VARCHAR(50),
  title TEXT,
  message TEXT,
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP,
  
  INDEX idx_user_read (user_id, read)
);

âœ… ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸
í•µì‹¬ ê¸°ëŠ¥
âœ… íšŒì›ê°€ì… ì‹œ ì—­í•  ì„ íƒ (í•™ìƒ/ì„ ìƒë‹˜)
âœ… êµ¬ë… í”Œëœ ë¶„ë¦¬ (í•™ìƒ/ì„ ìƒë‹˜)
âœ… ê°„ë‹¨ ëª¨ë“œ (ê¸°ë³¸/ê³ ê¸‰ ì„¤ì •)
âœ… ì»¤ìŠ¤í…€ ëª¨ë“œ (4ë‹¨ê³„)
âœ… Speaking 3ê°€ì§€ íƒ€ì…
âœ… ìˆ™ì œ ì‹œìŠ¤í…œ (ìƒì„±/ë¶€ì—¬/ì±„ì /ì¬ì‹œë„)
âœ… í•™ìƒ ê´€ë¦¬ (ì´ë©”ì¼/ì½”ë“œ ì´ˆëŒ€, 1:1 ê´€ê³„)
âœ… ë§ˆê°ì¼ ê´€ë¦¬ (ì—°ì¥ ê°€ëŠ¥)
âœ… PWA (ì˜¤í”„ë¼ì¸ ì§€ì›)
âœ… ê²°ì œ (Stripe + Toss, 7ì¼ ì²´í—˜, 7ì¼ í™˜ë¶ˆ)
ê¸°ìˆ  ìŠ¤íƒ
Frontend: Next.js 14, React, TypeScript, Tailwind
Backend: Supabase (Auth, DB, Realtime)
AI: GPT-4o mini, GPT-4o, Claude Haiku 4.5
Payment: Stripe, Toss Payments
TTS/STT: OpenAI Whisper, OpenAI TTS
PWA: next-pwa
ì˜ˆìƒ ë¹„ìš© (ì›”)
AI: ~$150
Supabase: ~$25
Stripe/Toss: ~$30 (ìˆ˜ìˆ˜ë£Œ)
ì´: ~$200
ìˆ˜ìµ: ~$4,000 (200ëª… ê¸°ì¤€)
ë§ˆì§„: 95%